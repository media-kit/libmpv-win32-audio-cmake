diff --git a/meson.build b/meson.build
index b7bcb1b0ba..b7bc29f896 100644
--- a/meson.build
+++ b/meson.build
@@ -29,12 +29,7 @@ libswscale = dependency('libswscale', version: '>= 7.5.100')
 libplacebo = dependency('libplacebo', version: '>=6.338.2',
                 default_options: ['default_library=static', 'demos=false'])
 
-libass = dependency('libass', version: '>= 0.12.2')
-
-# the dependency order of libass -> ffmpeg is necessary due to
-# static linking symbol resolution between fontconfig and MinGW
-dependencies = [libass,
-                libavcodec,
+dependencies = [libavcodec,
                 libavfilter,
                 libavformat,
                 libavutil,
@@ -47,7 +42,6 @@ features = {
     'debug': get_option('debug'),
     'ffmpeg': true,
     'gpl': get_option('gpl'),
-    'libass': true,
     'libplacebo': true,
 }
 
@@ -187,15 +181,12 @@ sources = files(
     'stream/stream_slice.c',
 
     ## Subtitles
-    'sub/ass_mp.c',
     'sub/dec_sub.c',
     'sub/draw_bmp.c',
     'sub/filter_sdh.c',
     'sub/img_convert.c',
     'sub/lavc_conv.c',
     'sub/osd.c',
-    'sub/osd_libass.c',
-    'sub/sd_ass.c',
     'sub/sd_lavc.c',
 
     ## Video
diff --git a/player/command.c b/player/command.c
index 6891f4e70f..faae79ed11 100644
--- a/player/command.c
+++ b/player/command.c
@@ -25,7 +25,6 @@
 #include <math.h>
 #include <sys/types.h>
 
-#include <ass/ass.h>
 #include <libavutil/avstring.h>
 #include <libavutil/common.h>
 
@@ -3518,7 +3517,7 @@ static int mp_property_ffmpeg(void *ctx, struct m_property *prop,
 static int mp_property_libass_version(void *ctx, struct m_property *prop,
                                       int action, void *arg)
 {
-    return m_property_int64_ro(action, arg, ass_library_version());
+    return m_property_int64_ro(action, arg, 0);
 }
 
 static int mp_property_platform(void *ctx, struct m_property *prop,
diff --git a/sub/ass_mp.c b/sub/ass_mp.c
deleted file mode 100644
index 255d0a077f..0000000000
--- a/sub/ass_mp.c
+++ /dev/null
@@ -1,419 +0,0 @@
-/*
- * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <inttypes.h>
-#include <string.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <stdbool.h>
-#include <assert.h>
-#include <math.h>
-
-#include <ass/ass.h>
-#include <ass/ass_types.h>
-
-#include "common/common.h"
-#include "common/global.h"
-#include "common/msg.h"
-#include "options/path.h"
-#include "ass_mp.h"
-#include "img_convert.h"
-#include "osd.h"
-#include "stream/stream.h"
-#include "options/options.h"
-#include "video/out/bitmap_packer.h"
-#include "video/mp_image.h"
-
-// res_y should be track->PlayResY
-// It determines scaling of font sizes and more.
-void mp_ass_set_style(ASS_Style *style, double res_y,
-                      const struct osd_style_opts *opts)
-{
-    if (!style)
-        return;
-
-    if (opts->font) {
-        if (!style->FontName || strcmp(style->FontName, opts->font) != 0) {
-            free(style->FontName);
-            style->FontName = strdup(opts->font);
-        }
-    }
-
-    // libass_font_size = FontSize * (window_height / res_y)
-    // scale translates parameters from PlayResY=720 to res_y
-    double scale = res_y / 720.0;
-
-    style->FontSize = opts->font_size * scale;
-    style->PrimaryColour = MP_ASS_COLOR(opts->color);
-    style->SecondaryColour = style->PrimaryColour;
-    style->OutlineColour = MP_ASS_COLOR(opts->outline_color);
-    style->BackColour = MP_ASS_COLOR(opts->back_color);
-    style->BorderStyle = opts->border_style;
-    style->Outline = opts->outline_size * scale;
-    style->Shadow = opts->shadow_offset * scale;
-    style->Spacing = opts->spacing * scale;
-    style->MarginL = opts->margin_x * scale;
-    style->MarginR = style->MarginL;
-    style->MarginV = opts->margin_y * scale;
-    style->ScaleX = 1.;
-    style->ScaleY = 1.;
-    style->Alignment = 1 + (opts->align_x + 1) + (opts->align_y + 2) % 3 * 4;
-#ifdef ASS_JUSTIFY_LEFT
-    style->Justify = opts->justify;
-#endif
-    style->Blur = opts->blur;
-    style->Bold = opts->bold;
-    style->Italic = opts->italic;
-}
-
-void mp_ass_configure_fonts(ASS_Renderer *priv, struct osd_style_opts *opts,
-                            struct mpv_global *global, struct mp_log *log)
-{
-    void *tmp = talloc_new(NULL);
-    char *default_font = mp_find_config_file(tmp, global, "subfont.ttf");
-    char *config       = mp_find_config_file(tmp, global, "fonts.conf");
-
-    if (default_font && !mp_path_exists(default_font))
-        default_font = NULL;
-
-    int font_provider = ASS_FONTPROVIDER_AUTODETECT;
-    if (opts->font_provider == 1)
-        font_provider = ASS_FONTPROVIDER_NONE;
-    if (opts->font_provider == 2)
-        font_provider = ASS_FONTPROVIDER_FONTCONFIG;
-
-    mp_verbose(log, "Setting up fonts...\n");
-    ass_set_fonts(priv, default_font, opts->font, font_provider, config, 1);
-    mp_verbose(log, "Done.\n");
-
-    talloc_free(tmp);
-}
-
-static const int map_ass_level[] = {
-    MSGL_ERR,           // 0 "FATAL errors"
-    MSGL_WARN,
-    MSGL_INFO,
-    MSGL_V,
-    MSGL_V,
-    MSGL_DEBUG,         // 5 application recommended level
-    MSGL_TRACE,
-    MSGL_TRACE,         // 7 "verbose DEBUG"
-};
-
-PRINTF_ATTRIBUTE(2, 0)
-static void message_callback(int level, const char *format, va_list va, void *ctx)
-{
-    struct mp_log *log = ctx;
-    if (!log)
-        return;
-    level = map_ass_level[level];
-    mp_msg_va(log, level, format, va);
-    // libass messages lack trailing \n
-    mp_msg(log, level, "\n");
-}
-
-ASS_Library *mp_ass_init(struct mpv_global *global,
-                         struct osd_style_opts *opts, struct mp_log *log)
-{
-    char *path = opts->fonts_dir && opts->fonts_dir[0] ?
-                 mp_get_user_path(NULL, global, opts->fonts_dir) :
-                 mp_find_config_file(NULL, global, "fonts");
-    mp_dbg(log, "ASS library version: 0x%x (runtime 0x%x)\n",
-           (unsigned)LIBASS_VERSION, ass_library_version());
-    ASS_Library *priv = ass_library_init();
-    if (!priv)
-        abort();
-    ass_set_message_cb(priv, message_callback, log);
-    if (path)
-        ass_set_fonts_dir(priv, path);
-    talloc_free(path);
-    return priv;
-}
-
-void mp_ass_flush_old_events(ASS_Track *track, long long ts)
-{
-    int n = 0;
-    for (; n < track->n_events; n++) {
-        if ((track->events[n].Start + track->events[n].Duration) >= ts)
-            break;
-        ass_free_event(track, n);
-        track->n_events--;
-    }
-    for (int i = 0; n > 0 && i < track->n_events; i++) {
-        track->events[i] = track->events[i+n];
-    }
-}
-
-static void draw_ass_rgba(unsigned char *src, int src_w, int src_h,
-                          int src_stride, unsigned char *dst, size_t dst_stride,
-                          int dst_x, int dst_y, uint32_t color)
-{
-    const unsigned int r = (color >> 24) & 0xff;
-    const unsigned int g = (color >> 16) & 0xff;
-    const unsigned int b = (color >>  8) & 0xff;
-    const unsigned int a = 0xff - (color & 0xff);
-
-    dst += dst_y * dst_stride + dst_x * 4;
-
-    for (int y = 0; y < src_h; y++, dst += dst_stride, src += src_stride) {
-        uint32_t *dstrow = (uint32_t *) dst;
-        for (int x = 0; x < src_w; x++) {
-            const unsigned int v = src[x];
-            int rr = (r * a * v);
-            int gg = (g * a * v);
-            int bb = (b * a * v);
-            int aa =      a * v;
-            uint32_t dstpix = dstrow[x];
-            unsigned int dstb =  dstpix        & 0xFF;
-            unsigned int dstg = (dstpix >>  8) & 0xFF;
-            unsigned int dstr = (dstpix >> 16) & 0xFF;
-            unsigned int dsta = (dstpix >> 24) & 0xFF;
-            dstb = (bb       + dstb * (255 * 255 - aa)) / (255 * 255);
-            dstg = (gg       + dstg * (255 * 255 - aa)) / (255 * 255);
-            dstr = (rr       + dstr * (255 * 255 - aa)) / (255 * 255);
-            dsta = (aa * 255 + dsta * (255 * 255 - aa)) / (255 * 255);
-            dstrow[x] = dstb | (dstg << 8) | (dstr << 16) | (dsta << 24);
-        }
-    }
-}
-
-struct mp_ass_packer {
-    struct sub_bitmap *cached_parts; // only for the array memory
-    struct mp_image *cached_img;
-    struct sub_bitmaps cached_subs;
-    bool cached_subs_valid;
-    struct sub_bitmap rgba_imgs[MP_SUB_BB_LIST_MAX];
-    struct bitmap_packer *packer;
-};
-
-// Free with talloc_free().
-struct mp_ass_packer *mp_ass_packer_alloc(void *ta_parent)
-{
-    struct mp_ass_packer *p = talloc_zero(ta_parent, struct mp_ass_packer);
-    p->packer = talloc_zero(p, struct bitmap_packer);
-    return p;
-}
-
-static bool pack(struct mp_ass_packer *p, struct sub_bitmaps *res, int imgfmt)
-{
-    packer_set_size(p->packer, res->num_parts);
-
-    for (int n = 0; n < res->num_parts; n++)
-        p->packer->in[n] = (struct pos){res->parts[n].w, res->parts[n].h};
-
-    if (p->packer->count == 0 || packer_pack(p->packer) < 0)
-        return false;
-
-    struct pos bb[2];
-    packer_get_bb(p->packer, bb);
-
-    res->packed_w = bb[1].x;
-    res->packed_h = bb[1].y;
-
-    if (!p->cached_img || p->cached_img->w < res->packed_w ||
-                          p->cached_img->h < res->packed_h ||
-                          p->cached_img->imgfmt != imgfmt)
-    {
-        talloc_free(p->cached_img);
-        p->cached_img = mp_image_alloc(imgfmt, p->packer->w, p->packer->h);
-        if (!p->cached_img) {
-            packer_reset(p->packer);
-            return false;
-        }
-        talloc_steal(p, p->cached_img);
-    }
-
-    if (!mp_image_make_writeable(p->cached_img)) {
-        packer_reset(p->packer);
-        return false;
-    }
-
-    res->packed = p->cached_img;
-
-    for (int n = 0; n < res->num_parts; n++) {
-        struct sub_bitmap *b = &res->parts[n];
-        struct pos pos = p->packer->result[n];
-
-        b->src_x = pos.x;
-        b->src_y = pos.y;
-    }
-
-    return true;
-}
-
-static bool pack_libass(struct mp_ass_packer *p, struct sub_bitmaps *res)
-{
-    if (!pack(p, res, IMGFMT_Y8))
-        return false;
-
-    for (int n = 0; n < res->num_parts; n++) {
-        struct sub_bitmap *b = &res->parts[n];
-
-        int stride = res->packed->stride[0];
-        void *pdata =
-            (uint8_t *)res->packed->planes[0] + b->src_y * stride + b->src_x;
-        memcpy_pic(pdata, b->bitmap, b->w, b->h, stride, b->stride);
-
-        b->bitmap = pdata;
-        b->stride = stride;
-    }
-
-    return true;
-}
-
-static bool pack_rgba(struct mp_ass_packer *p, struct sub_bitmaps *res)
-{
-    struct mp_rect bb_list[MP_SUB_BB_LIST_MAX];
-    int num_bb = mp_get_sub_bb_list(res, bb_list, MP_SUB_BB_LIST_MAX);
-
-    struct sub_bitmaps imgs = {
-        .change_id = res->change_id,
-        .format = SUBBITMAP_BGRA,
-        .parts = p->rgba_imgs,
-        .num_parts = num_bb,
-    };
-
-    for (int n = 0; n < imgs.num_parts; n++) {
-        imgs.parts[n].w = bb_list[n].x1 - bb_list[n].x0;
-        imgs.parts[n].h = bb_list[n].y1 - bb_list[n].y0;
-    }
-
-    if (!pack(p, &imgs, IMGFMT_BGRA))
-        return false;
-
-    for (int n = 0; n < num_bb; n++) {
-        struct mp_rect bb = bb_list[n];
-        struct sub_bitmap *b = &imgs.parts[n];
-
-        b->x = bb.x0;
-        b->y = bb.y0;
-        b->w = b->dw = bb.x1 - bb.x0;
-        b->h = b->dh = bb.y1 - bb.y0;
-        b->stride = imgs.packed->stride[0];
-        b->bitmap = (uint8_t *)imgs.packed->planes[0] +
-                    b->stride * b->src_y + b->src_x * 4;
-
-        memset_pic(b->bitmap, 0, b->w * 4, b->h, b->stride);
-
-        for (int i = 0; i < res->num_parts; i++) {
-            struct sub_bitmap *s = &res->parts[i];
-
-            // Assume mp_get_sub_bb_list() never splits sub bitmaps
-            // So we don't clip/adjust the size of the sub bitmap
-            if (s->x > bb.x1 || s->x + s->w < bb.x0 ||
-                s->y > bb.y1 || s->y + s->h < bb.y0)
-                continue;
-
-            draw_ass_rgba(s->bitmap, s->w, s->h, s->stride,
-                          b->bitmap, b->stride,
-                          s->x - bb.x0, s->y - bb.y0,
-                          s->libass.color);
-        }
-    }
-
-    *res = imgs;
-    return true;
-}
-
-// Pack the contents of image_lists[0] to image_lists[num_image_lists-1] into
-// a single image, and make *out point to it. *out is completely overwritten.
-// If libass reported any change, image_lists_changed must be set (it then
-// repacks all images). preferred_osd_format can be set to a desired
-// sub_bitmap_format. Currently, only SUBBITMAP_LIBASS is supported.
-void mp_ass_packer_pack(struct mp_ass_packer *p, ASS_Image **image_lists,
-                        int num_image_lists, bool image_lists_changed, bool video_color_space,
-                        int preferred_osd_format, struct sub_bitmaps *out)
-{
-    int format = preferred_osd_format == SUBBITMAP_BGRA ? SUBBITMAP_BGRA
-                                                        : SUBBITMAP_LIBASS;
-
-    if (p->cached_subs_valid && !image_lists_changed &&
-        p->cached_subs.format == format)
-    {
-        *out = p->cached_subs;
-        return;
-    }
-
-    *out = (struct sub_bitmaps){.change_id = 1};
-    p->cached_subs_valid = false;
-
-    struct sub_bitmaps res = {
-        .change_id = image_lists_changed,
-        .format = SUBBITMAP_LIBASS,
-        .parts = p->cached_parts,
-        .video_color_space = video_color_space,
-    };
-
-    for (int n = 0; n < num_image_lists; n++) {
-        for (struct ass_image *img = image_lists[n]; img; img = img->next) {
-            if (img->w == 0 || img->h == 0)
-                continue;
-            MP_TARRAY_GROW(p, p->cached_parts, res.num_parts);
-            res.parts = p->cached_parts;
-            struct sub_bitmap *b = &res.parts[res.num_parts];
-            b->bitmap = img->bitmap;
-            b->stride = img->stride;
-            b->libass.color = img->color;
-            b->dw = b->w = img->w;
-            b->dh = b->h = img->h;
-            b->x = img->dst_x;
-            b->y = img->dst_y;
-            res.num_parts++;
-        }
-    }
-
-    bool r = false;
-    if (format == SUBBITMAP_BGRA) {
-        r = pack_rgba(p, &res);
-    } else {
-        r = pack_libass(p, &res);
-    }
-
-    if (!r)
-        return;
-
-    *out = res;
-    p->cached_subs = res;
-    p->cached_subs.change_id = 0;
-    p->cached_subs_valid = true;
-}
-
-// Set *out_rc to [x0, y0, x1, y1] of the graphical bounding box in script
-// coordinates.
-// Set it to [inf, inf, -inf, -inf] if empty.
-void mp_ass_get_bb(ASS_Image *image_list, ASS_Track *track,
-                   struct mp_osd_res *res, double *out_rc)
-{
-    double rc[4] = {INFINITY, INFINITY, -INFINITY, -INFINITY};
-
-    for (ASS_Image *img = image_list; img; img = img->next) {
-        if (img->w == 0 || img->h == 0)
-            continue;
-        rc[0] = MPMIN(rc[0], img->dst_x);
-        rc[1] = MPMIN(rc[1], img->dst_y);
-        rc[2] = MPMAX(rc[2], img->dst_x + img->w);
-        rc[3] = MPMAX(rc[3], img->dst_y + img->h);
-    }
-
-    double scale = track->PlayResY / (double)MPMAX(res->h, 1);
-    if (scale > 0) {
-        for (int i = 0; i < 4; i++)
-            out_rc[i] = rc[i] * scale;
-    }
-}
diff --git a/sub/ass_mp.h b/sub/ass_mp.h
deleted file mode 100644
index b4e16d6650..0000000000
--- a/sub/ass_mp.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MPLAYER_ASS_MP_H
-#define MPLAYER_ASS_MP_H
-
-#include <stdint.h>
-#include <stdbool.h>
-
-#include <ass/ass.h>
-#include <ass/ass_types.h>
-
-// These PlayResX and PlayResY values are arbitrary and taken from lavc.
-// lavc assumes these values when converting to ass generally. Moreover, these
-// values are also used by default in VSFilter, so it isn't that arbitrary.
-#define MP_ASS_FONT_PLAYRESX 384
-#define MP_ASS_FONT_PLAYRESY 288
-
-#define MP_ASS_RGBA(r, g, b, a) \
-    (((unsigned)(r) << 24) | ((g) << 16) | ((b) << 8) | (0xFF - (a)))
-
-// m_color argument
-#define MP_ASS_COLOR(c) MP_ASS_RGBA((c).r, (c).g, (c).b, (c).a)
-
-struct MPOpts;
-struct mpv_global;
-struct mp_osd_res;
-struct osd_style_opts;
-struct mp_log;
-
-void mp_ass_flush_old_events(ASS_Track *track, long long ts);
-void mp_ass_set_style(ASS_Style *style, double res_y,
-                      const struct osd_style_opts *opts);
-
-void mp_ass_configure_fonts(ASS_Renderer *priv, struct osd_style_opts *opts,
-                            struct mpv_global *global, struct mp_log *log);
-ASS_Library *mp_ass_init(struct mpv_global *global,
-                         struct osd_style_opts *opts, struct mp_log *log);
-
-struct sub_bitmaps;
-struct mp_ass_packer;
-struct mp_ass_packer *mp_ass_packer_alloc(void *ta_parent);
-void mp_ass_packer_pack(struct mp_ass_packer *p, ASS_Image **image_lists,
-                        int num_image_lists, bool changed, bool video_color_space,
-                        int preferred_osd_format, struct sub_bitmaps *out);
-void mp_ass_get_bb(ASS_Image *image_list, ASS_Track *track,
-                   struct mp_osd_res *res, double *out_rc);
-
-#endif                          /* MPLAYER_ASS_MP_H */
diff --git a/sub/dec_sub.c b/sub/dec_sub.c
index ce51fdf8c8..c0297ab590 100644
--- a/sub/dec_sub.c
+++ b/sub/dec_sub.c
@@ -33,12 +33,10 @@
 #include "misc/dispatch.h"
 #include "osdep/threads.h"
 
-extern const struct sd_functions sd_ass;
 extern const struct sd_functions sd_lavc;
 
 static const struct sd_functions *const sd_list[] = {
     &sd_lavc,
-    &sd_ass,
     NULL
 };
 
diff --git a/sub/osd_libass.c b/sub/osd_libass.c
deleted file mode 100644
index 8ce203e66e..0000000000
--- a/sub/osd_libass.c
+++ /dev/null
@@ -1,687 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
-#include "mpv_talloc.h"
-#include "misc/bstr.h"
-#include "common/common.h"
-#include "common/msg.h"
-#include "osd.h"
-#include "osd_state.h"
-
-static const char osd_font_pfb[] =
-#include "sub/osd_font.otf.inc"
-;
-
-#include "sub/ass_mp.h"
-#include "options/options.h"
-
-
-#define ASS_USE_OSD_FONT "{\\fnmpv-osd-symbols}"
-
-static void append_ass(struct ass_state *ass, struct mp_osd_res *res,
-                       ASS_Image **img_list, bool *changed);
-
-static void create_ass_renderer(struct osd_state *osd, struct ass_state *ass)
-{
-    if (ass->render)
-        return;
-
-    ass->log = mp_log_new(NULL, osd->log, "libass");
-    ass->library = mp_ass_init(osd->global, osd->opts->osd_style, ass->log);
-    ass_add_font(ass->library, "mpv-osd-symbols", (void *)osd_font_pfb,
-                 sizeof(osd_font_pfb) - 1);
-
-    ass->render = ass_renderer_init(ass->library);
-    if (!ass->render)
-        abort();
-
-    mp_ass_configure_fonts(ass->render, osd->opts->osd_style,
-                           osd->global, ass->log);
-    ass_set_pixel_aspect(ass->render, 1.0);
-}
-
-static void destroy_ass_renderer(struct ass_state *ass)
-{
-    if (ass->track)
-        ass_free_track(ass->track);
-    ass->track = NULL;
-    if (ass->render)
-        ass_renderer_done(ass->render);
-    ass->render = NULL;
-    if (ass->library)
-        ass_library_done(ass->library);
-    ass->library = NULL;
-    talloc_free(ass->log);
-    ass->log = NULL;
-}
-
-static void destroy_external(struct osd_external *ext)
-{
-    destroy_ass_renderer(&ext->ass);
-    talloc_free(ext);
-}
-
-void osd_destroy_backend(struct osd_state *osd)
-{
-    for (int n = 0; n < MAX_OSD_PARTS; n++) {
-        struct osd_object *obj = osd->objs[n];
-        destroy_ass_renderer(&obj->ass);
-        for (int i = 0; i < obj->num_externals; i++)
-            destroy_external(obj->externals[i]);
-        obj->num_externals = 0;
-    }
-}
-
-static void update_playres(struct ass_state *ass, struct mp_osd_res *vo_res)
-{
-    ASS_Track *track = ass->track;
-    int old_res_x = track->PlayResX;
-    int old_res_y = track->PlayResY;
-
-    ass->vo_res = *vo_res;
-
-    double aspect = 1.0 * vo_res->w / MPMAX(vo_res->h, 1);
-    if (vo_res->display_par > 0)
-        aspect = aspect / vo_res->display_par;
-
-    track->PlayResY = ass->res_y ? ass->res_y : MP_ASS_FONT_PLAYRESY;
-    track->PlayResX = ass->res_x ? ass->res_x : track->PlayResY * aspect;
-
-    // Force libass to clear its internal cache - it doesn't check for
-    // PlayRes changes itself.
-    if (old_res_x != track->PlayResX || old_res_y != track->PlayResY)
-        ass_set_frame_size(ass->render, 1, 1);
-}
-
-static void create_ass_track(struct osd_state *osd, struct osd_object *obj,
-                             struct ass_state *ass)
-{
-    create_ass_renderer(osd, ass);
-
-    ASS_Track *track = ass->track;
-    if (!track)
-        track = ass->track = ass_new_track(ass->library);
-
-    track->track_type = TRACK_TYPE_ASS;
-    track->Timer = 100.;
-    track->WrapStyle = 1; // end-of-line wrapping instead of smart wrapping
-    track->Kerning = true;
-    track->ScaledBorderAndShadow = true;
-#if LIBASS_VERSION >= 0x01600010
-    ass_track_set_feature(track, ASS_FEATURE_WRAP_UNICODE, 1);
-#endif
-    update_playres(ass, &obj->vo_res);
-}
-
-static int find_style(ASS_Track *track, const char *name, int def)
-{
-    for (int n = 0; n < track->n_styles; n++) {
-        if (track->styles[n].Name && strcmp(track->styles[n].Name, name) == 0)
-            return n;
-    }
-    return def;
-}
-
-// Find a given style, or add it if it's missing.
-static ASS_Style *get_style(struct ass_state *ass, char *name)
-{
-    ASS_Track *track = ass->track;
-    if (!track)
-        return NULL;
-
-    int sid = find_style(track, name, -1);
-    if (sid >= 0)
-        return &track->styles[sid];
-
-    sid = ass_alloc_style(track);
-    ASS_Style *style = &track->styles[sid];
-    style->Name = strdup(name);
-    // Set to neutral base direction, as opposed to VSFilter LTR default
-    style->Encoding = -1;
-    return style;
-}
-
-static ASS_Event *add_osd_ass_event(ASS_Track *track, const char *style,
-                                    const char *text)
-{
-    int n = ass_alloc_event(track);
-    ASS_Event *event = track->events + n;
-    event->Start = 0;
-    event->Duration = 100;
-    event->Style = find_style(track, style, 0);
-    event->ReadOrder = n;
-    assert(event->Text == NULL);
-    if (text)
-        event->Text = strdup(text);
-    return event;
-}
-
-static void clear_ass(struct ass_state *ass)
-{
-    if (ass->track)
-        ass_flush_events(ass->track);
-}
-
-void osd_get_function_sym(char *buffer, size_t buffer_size, int osd_function)
-{
-    // 0xFF is never valid UTF-8, so we can use it to escape OSD symbols.
-    // (Same trick as OSD_ASS_0/OSD_ASS_1.)
-    snprintf(buffer, buffer_size, "\xFF%c", osd_function);
-}
-
-void osd_mangle_ass(bstr *dst, const char *in, bool replace_newlines)
-{
-    const char *start = in;
-    bool escape_ass = true;
-    while (*in) {
-        // As used by osd_get_function_sym().
-        if (in[0] == '\xFF' && in[1]) {
-            bstr_xappend(NULL, dst, bstr0(ASS_USE_OSD_FONT));
-            mp_append_utf8_bstr(NULL, dst, OSD_CODEPOINTS + in[1]);
-            bstr_xappend(NULL, dst, bstr0("{\\r}"));
-            in += 2;
-            continue;
-        }
-        if (*in == OSD_ASS_0[0] || *in == OSD_ASS_1[0]) {
-            escape_ass = *in == OSD_ASS_1[0];
-            in += 1;
-            continue;
-        }
-        if (escape_ass && *in == '{')
-            bstr_xappend(NULL, dst, bstr0("\\"));
-        // Replace newlines with \N for escape-ass. This is necessary to apply
-        // ASS tags past newlines and to preserve consecutive newlines with
-        // osd-overlay because update_external() adds a ASS event per line.
-        if (replace_newlines && *in == '\n') {
-            bstr_xappend(NULL, dst, bstr0("\\N"));
-            in += 1;
-            continue;
-        }
-        // Libass will strip leading whitespace
-        if (in[0] == ' ' && (in == start || in[-1] == '\n')) {
-            bstr_xappend(NULL, dst, bstr0("\\h"));
-            in += 1;
-            continue;
-        }
-        bstr_xappend(NULL, dst, (bstr){(char *)in, 1});
-        // Break ASS escapes with U+2060 WORD JOINER
-        if (escape_ass && *in == '\\')
-            mp_append_utf8_bstr(NULL, dst, 0x2060);
-        in++;
-    }
-}
-
-static ASS_Event *add_osd_ass_event_escaped(ASS_Track *track, const char *style,
-                                            const char *text)
-{
-    bstr buf = {0};
-    osd_mangle_ass(&buf, text, false);
-    ASS_Event *e = add_osd_ass_event(track, style, buf.start);
-    talloc_free(buf.start);
-    return e;
-}
-
-static ASS_Style *prepare_osd_ass(struct osd_state *osd, struct osd_object *obj)
-{
-    struct mp_osd_render_opts *opts = osd->opts;
-
-    create_ass_track(osd, obj, &obj->ass);
-
-    struct osd_style_opts font = *opts->osd_style;
-    font.font_size *= opts->osd_scale;
-
-    double playresy = obj->ass.track->PlayResY;
-    // Compensate for libass and mp_ass_set_style scaling the font etc.
-    if (!opts->osd_scale_by_window)
-        playresy *= 720.0 / obj->vo_res.h;
-
-    ASS_Style *style = get_style(&obj->ass, "OSD");
-    mp_ass_set_style(style, playresy, &font);
-    return style;
-}
-
-static void update_osd_text(struct osd_state *osd, struct osd_object *obj)
-{
-
-    if (!obj->text[0])
-        return;
-
-    prepare_osd_ass(osd, obj);
-    add_osd_ass_event_escaped(obj->ass.track, "OSD", obj->text);
-}
-
-void osd_get_text_size(struct osd_state *osd, int *out_screen_h, int *out_font_h)
-{
-    mp_mutex_lock(&osd->lock);
-    struct osd_object *obj = osd->objs[OSDTYPE_OSD];
-    ASS_Style *style = prepare_osd_ass(osd, obj);
-    *out_screen_h = obj->ass.track->PlayResY - style->MarginV;
-    *out_font_h = style->FontSize;
-    mp_mutex_unlock(&osd->lock);
-}
-
-// align: -1 .. +1
-// frame: size of the containing area
-// obj: size of the object that should be positioned inside the area
-// margin: min. distance from object to frame (as long as -1 <= align <= +1)
-static float get_align(float align, float frame, float obj, float margin)
-{
-    frame -= margin * 2;
-    return margin + frame / 2 - obj / 2 + (frame - obj) / 2 * align;
-}
-
-struct ass_draw {
-    int scale;
-    char *text;
-};
-
-static void ass_draw_start(struct ass_draw *d)
-{
-    d->scale = MPMAX(d->scale, 1);
-    d->text = talloc_asprintf_append(d->text, "{\\p%d}", d->scale);
-}
-
-static void ass_draw_stop(struct ass_draw *d)
-{
-    d->text = talloc_strdup_append(d->text, "{\\p0}");
-}
-
-static void ass_draw_c(struct ass_draw *d, float x, float y)
-{
-    int ix = round(x * (1 << (d->scale - 1)));
-    int iy = round(y * (1 << (d->scale - 1)));
-    d->text = talloc_asprintf_append(d->text, " %d %d", ix, iy);
-}
-
-static void ass_draw_append(struct ass_draw *d, const char *t)
-{
-    d->text = talloc_strdup_append(d->text, t);
-}
-
-static void ass_draw_move_to(struct ass_draw *d, float x, float y)
-{
-    ass_draw_append(d, " m");
-    ass_draw_c(d, x, y);
-}
-
-static void ass_draw_line_to(struct ass_draw *d, float x, float y)
-{
-    ass_draw_append(d, " l");
-    ass_draw_c(d, x, y);
-}
-
-static void ass_draw_rect_ccw(struct ass_draw *d, float x0, float y0,
-                              float x1, float y1)
-{
-    ass_draw_move_to(d, x0, y0);
-    ass_draw_line_to(d, x0, y1);
-    ass_draw_line_to(d, x1, y1);
-    ass_draw_line_to(d, x1, y0);
-}
-
-static void ass_draw_rect_cw(struct ass_draw *d, float x0, float y0,
-                             float x1, float y1)
-{
-    ass_draw_move_to(d, x0, y0);
-    ass_draw_line_to(d, x1, y0);
-    ass_draw_line_to(d, x1, y1);
-    ass_draw_line_to(d, x0, y1);
-}
-
-static void ass_draw_reset(struct ass_draw *d)
-{
-    talloc_free(d->text);
-    d->text = NULL;
-}
-
-static void get_osd_bar_box(struct osd_state *osd, struct osd_object *obj,
-                            float *o_x, float *o_y, float *o_w, float *o_h,
-                            float *o_border)
-{
-    struct mp_osd_render_opts *opts = osd->opts;
-
-    create_ass_track(osd, obj, &obj->ass);
-    ASS_Track *track = obj->ass.track;
-
-    ASS_Style *style = get_style(&obj->ass, "progbar");
-    if (!style) {
-        *o_x = *o_y = *o_w = *o_h = *o_border = 0;
-        return;
-    }
-
-    mp_ass_set_style(style, track->PlayResY, opts->osd_style);
-
-    // override the default osd opaque-box into plain outline. Otherwise
-    // the opaque box is not aligned with the bar (even without shadow),
-    // and each bar ass event gets its own opaque box - breaking the bar.
-    style->BorderStyle = 1; // outline
-
-    *o_w = track->PlayResX * (opts->osd_bar_w / 100.0);
-    *o_h = track->PlayResY * (opts->osd_bar_h / 100.0);
-
-    style->Outline = opts->osd_bar_outline_size;
-    // Rendering with shadow is broken (because there's more than one shape)
-    style->Shadow = 0;
-
-    style->Alignment = 5;
-
-    *o_border = style->Outline;
-
-    *o_x = get_align(opts->osd_bar_align_x, track->PlayResX, *o_w, *o_border);
-    *o_y = get_align(opts->osd_bar_align_y, track->PlayResY, *o_h, *o_border);
-}
-
-static void update_progbar(struct osd_state *osd, struct osd_object *obj)
-{
-    if (obj->progbar_state.type < 0)
-        return;
-
-    float px, py, width, height, border;
-    get_osd_bar_box(osd, obj, &px, &py, &width, &height, &border);
-
-    ASS_Track *track = obj->ass.track;
-
-    float sx = px - border * 2 - height / 4; // includes additional spacing
-    float sy = py + height / 2;
-
-    bstr buf = bstr0(talloc_asprintf(NULL, "{\\an6\\pos(%f,%f)}", sx, sy));
-
-    if (obj->progbar_state.type == 0 || obj->progbar_state.type >= 256) {
-        // no sym
-    } else if (obj->progbar_state.type >= 32) {
-        mp_append_utf8_bstr(NULL, &buf, obj->progbar_state.type);
-    } else {
-        bstr_xappend(NULL, &buf, bstr0(ASS_USE_OSD_FONT));
-        mp_append_utf8_bstr(NULL, &buf, OSD_CODEPOINTS + obj->progbar_state.type);
-        bstr_xappend(NULL, &buf, bstr0("{\\r}"));
-    }
-
-    add_osd_ass_event(track, "progbar", buf.start);
-    talloc_free(buf.start);
-
-    struct ass_draw *d = &(struct ass_draw) { .scale = 4 };
-
-    if (osd->opts->osd_style->back_color.a && osd->opts->osd_style->border_style != 1) {
-        // the bar style always ignores the --osd-back-color config - it messes
-        // up the bar. draw an artificial box at the original back color.
-        struct m_color bc = osd->opts->osd_style->back_color;
-        d->text = talloc_asprintf_append(d->text,
-            "{\\pos(%f,%f)\\bord0\\1a&H%02X\\1c&H%02X%02X%02X&}",
-             px, py, 255 - bc.a, (int)bc.b, (int)bc.g, (int)bc.r);
-
-        ass_draw_start(d);
-        ass_draw_rect_cw(d, -border, -border, width + border, height + border);
-        ass_draw_stop(d);
-        add_osd_ass_event(track, "progbar", d->text);
-        ass_draw_reset(d);
-    }
-
-    // filled area
-    d->text = talloc_asprintf_append(d->text, "{\\bord0\\pos(%f,%f)}", px, py);
-    ass_draw_start(d);
-    float pos = obj->progbar_state.value * width - border / 2;
-    ass_draw_rect_cw(d, 0, 0, pos, height);
-    ass_draw_stop(d);
-    add_osd_ass_event(track, "progbar", d->text);
-    ass_draw_reset(d);
-
-    // position marker
-    d->text = talloc_asprintf_append(d->text, "{\\bord%f\\pos(%f,%f)}",
-                                     border / 2, px, py);
-    ass_draw_start(d);
-    ass_draw_move_to(d, pos + border / 2, 0);
-    ass_draw_line_to(d, pos + border / 2, height);
-    ass_draw_stop(d);
-    add_osd_ass_event(track, "progbar", d->text);
-    ass_draw_reset(d);
-
-    d->text = talloc_asprintf_append(d->text, "{\\pos(%f,%f)}", px, py);
-    ass_draw_start(d);
-
-    // the box
-    ass_draw_rect_cw(d, -border, -border, width + border, height + border);
-
-    // the "hole"
-    ass_draw_rect_ccw(d, 0, 0, width, height);
-
-    // chapter marks
-    for (int n = 0; n < obj->progbar_state.num_stops; n++) {
-        float s = obj->progbar_state.stops[n] * width;
-        float dent = MPMAX(border * 1.3, 1.6);
-
-        if (s > dent && s < width - dent) {
-            ass_draw_move_to(d, s + dent, 0);
-            ass_draw_line_to(d, s,        dent);
-            ass_draw_line_to(d, s - dent, 0);
-
-            ass_draw_move_to(d, s - dent, height);
-            ass_draw_line_to(d, s,        height - dent);
-            ass_draw_line_to(d, s + dent, height);
-        }
-    }
-
-    ass_draw_stop(d);
-    add_osd_ass_event(track, "progbar", d->text);
-    ass_draw_reset(d);
-}
-
-static void update_osd(struct osd_state *osd, struct osd_object *obj)
-{
-    obj->osd_changed = false;
-    clear_ass(&obj->ass);
-    update_osd_text(osd, obj);
-    update_progbar(osd, obj);
-}
-
-static void update_external(struct osd_state *osd, struct osd_object *obj,
-                            struct osd_external *ext)
-{
-    bstr t = bstr0(ext->ov.data);
-    ext->ass.res_x = ext->ov.res_x;
-    ext->ass.res_y = ext->ov.res_y;
-    create_ass_track(osd, obj, &ext->ass);
-
-    clear_ass(&ext->ass);
-
-    int resy = ext->ass.track->PlayResY;
-    mp_ass_set_style(get_style(&ext->ass, "OSD"), resy, osd->opts->osd_style);
-
-    // Some scripts will reference this style name with \r tags.
-    const struct osd_style_opts *def = osd_style_conf.defaults;
-    mp_ass_set_style(get_style(&ext->ass, "Default"), resy, def);
-
-    while (t.len) {
-        bstr line;
-        bstr_split_tok(t, "\n", &line, &t);
-        if (line.len) {
-            char *tmp = bstrdup0(NULL, line);
-            add_osd_ass_event(ext->ass.track, "OSD", tmp);
-            talloc_free(tmp);
-        }
-    }
-}
-
-static int cmp_zorder(const void *pa, const void *pb)
-{
-    const struct osd_external *a = *(struct osd_external **)pa;
-    const struct osd_external *b = *(struct osd_external **)pb;
-    return a->ov.z == b->ov.z ? 0 : (a->ov.z > b->ov.z ? 1 : -1);
-}
-
-void osd_set_external(struct osd_state *osd, struct osd_external_ass *ov)
-{
-    mp_mutex_lock(&osd->lock);
-    struct osd_object *obj = osd->objs[OSDTYPE_EXTERNAL];
-    bool zorder_changed = false;
-    int index = -1;
-
-    for (int n = 0; n < obj->num_externals; n++) {
-        struct osd_external *e = obj->externals[n];
-        if (e->ov.id == ov->id && e->ov.owner == ov->owner) {
-            index = n;
-            break;
-        }
-    }
-
-    if (index < 0) {
-        if (!ov->format)
-            goto done;
-        struct osd_external *new = talloc_zero(NULL, struct osd_external);
-        new->ov.owner = ov->owner;
-        new->ov.id = ov->id;
-        MP_TARRAY_APPEND(obj, obj->externals, obj->num_externals, new);
-        index = obj->num_externals - 1;
-        zorder_changed = true;
-    }
-
-    struct osd_external *entry = obj->externals[index];
-
-    if (!ov->format) {
-        if (!entry->ov.hidden) {
-            obj->changed = true;
-            osd->want_redraw_notification = true;
-        }
-        destroy_external(entry);
-        MP_TARRAY_REMOVE_AT(obj->externals, obj->num_externals, index);
-        goto done;
-    }
-
-    if (!entry->ov.hidden || !ov->hidden) {
-        obj->changed = true;
-        osd->want_redraw_notification = true;
-    }
-
-    entry->ov.format = ov->format;
-    if (!entry->ov.data)
-        entry->ov.data = talloc_strdup(entry, "");
-    entry->ov.data[0] = '\0'; // reuse memory allocation
-    entry->ov.data = talloc_strdup_append(entry->ov.data, ov->data);
-    entry->ov.res_x = ov->res_x;
-    entry->ov.res_y = ov->res_y;
-    zorder_changed |= entry->ov.z != ov->z;
-    entry->ov.z = ov->z;
-    entry->ov.hidden = ov->hidden;
-
-    update_external(osd, obj, entry);
-
-    if (zorder_changed) {
-        qsort(obj->externals, obj->num_externals, sizeof(obj->externals[0]),
-              cmp_zorder);
-    }
-
-    if (ov->out_rc) {
-        struct mp_osd_res vo_res = entry->ass.vo_res;
-        // Defined fallback if VO has not drawn this yet
-        if (vo_res.w < 1 || vo_res.h < 1) {
-            vo_res = (struct mp_osd_res){
-                .w = entry->ov.res_x,
-                .h = entry->ov.res_y,
-                .display_par = 1,
-            };
-            // According to osd-overlay command description.
-            if (vo_res.w < 1)
-                vo_res.w = 1280;
-            if (vo_res.h < 1)
-                vo_res.h = 720;
-        }
-
-        ASS_Image *img_list = NULL;
-        append_ass(&entry->ass, &vo_res, &img_list, NULL);
-
-        mp_ass_get_bb(img_list, entry->ass.track, &vo_res, ov->out_rc);
-    }
-
-done:
-    mp_mutex_unlock(&osd->lock);
-}
-
-void osd_set_external_remove_owner(struct osd_state *osd, void *owner)
-{
-    mp_mutex_lock(&osd->lock);
-    struct osd_object *obj = osd->objs[OSDTYPE_EXTERNAL];
-    for (int n = obj->num_externals - 1; n >= 0; n--) {
-        struct osd_external *e = obj->externals[n];
-        if (e->ov.owner == owner) {
-            destroy_external(e);
-            MP_TARRAY_REMOVE_AT(obj->externals, obj->num_externals, n);
-            obj->changed = true;
-            osd->want_redraw_notification = true;
-        }
-    }
-    mp_mutex_unlock(&osd->lock);
-}
-
-static void append_ass(struct ass_state *ass, struct mp_osd_res *res,
-                       ASS_Image **img_list, bool *changed)
-{
-    if (!ass->render || !ass->track) {
-        *img_list = NULL;
-        return;
-    }
-
-    update_playres(ass, res);
-
-    ass_set_frame_size(ass->render, res->w, res->h);
-    ass_set_pixel_aspect(ass->render, res->display_par);
-
-    int ass_changed;
-    *img_list = ass_render_frame(ass->render, ass->track, 0, &ass_changed);
-
-    ass->changed |= ass_changed;
-
-    if (changed) {
-        *changed |= ass->changed;
-        ass->changed = false;
-    }
-}
-
-struct sub_bitmaps *osd_object_get_bitmaps(struct osd_state *osd,
-                                           struct osd_object *obj, int format)
-{
-    if (obj->type == OSDTYPE_OSD && obj->osd_changed)
-        update_osd(osd, obj);
-
-    if (!obj->ass_packer)
-        obj->ass_packer = mp_ass_packer_alloc(obj);
-
-    MP_TARRAY_GROW(obj, obj->ass_imgs, obj->num_externals + 1);
-
-    append_ass(&obj->ass, &obj->vo_res, &obj->ass_imgs[0], &obj->changed);
-    for (int n = 0; n < obj->num_externals; n++) {
-        if (obj->externals[n]->ov.hidden) {
-            update_playres(&obj->externals[n]->ass, &obj->vo_res);
-            obj->ass_imgs[n + 1] = NULL;
-        } else {
-            append_ass(&obj->externals[n]->ass, &obj->vo_res,
-                       &obj->ass_imgs[n + 1], &obj->changed);
-        }
-    }
-
-    struct sub_bitmaps out_imgs = {0};
-    mp_ass_packer_pack(obj->ass_packer, obj->ass_imgs, obj->num_externals + 1,
-                       obj->changed, false, format, &out_imgs);
-
-    obj->changed = false;
-
-    return sub_bitmaps_copy(&obj->copy_cache, &out_imgs);
-}
diff --git a/sub/osd_state.h b/sub/osd_state.h
index ef0ff20a57..725568234f 100644
--- a/sub/osd_state.h
+++ b/sub/osd_state.h
@@ -87,7 +87,7 @@ struct osd_state {
 
 // defined in osd_libass.c
 struct sub_bitmaps *osd_object_get_bitmaps(struct osd_state *osd,
-                                           struct osd_object *obj, int format);
-void osd_destroy_backend(struct osd_state *osd);
+                                           struct osd_object *obj, int format) { return NULL; }
+void osd_destroy_backend(struct osd_state *osd) {}
 
 #endif
diff --git a/sub/sd.h b/sub/sd.h
index cb80c2eb22..10cde787ba 100644
--- a/sub/sd.h
+++ b/sub/sd.h
@@ -108,17 +108,27 @@ extern const struct sd_filter_functions sd_filter_jsre;
 
 // num commas to skip at an ass-event before the "Text" field (always last)
 // (doesn't change, can be retrieved once on filter init)
-int sd_ass_fmt_offset(const char *event_format);
+inline int sd_ass_fmt_offset(const char *event_format) { return 0; }
 
 // the event (pkt->buffer) "Text" content according to the calculated offset.
 // on malformed event: warns and returns (bstr){NULL,0}
-bstr sd_ass_pkt_text(struct sd_filter *ft, struct demux_packet *pkt, int offset);
+inline bstr sd_ass_pkt_text(struct sd_filter *ft, struct demux_packet *pkt, int offset) {
+    struct bstr r;
+    r.start = NULL;
+    r.len = 0;
+    return r;
+}
 
 // convert \0-terminated "Text" (ass) content to plaintext, possibly in-place.
 // result.start is *out, result.len is strlen(in) or smaller.
 // (*out)[result.len] is always set to \0. *out == in is allowed.
 // *out must be a talloc-allocated buffer or NULL, and will be reallocated if needed.
 // *out will not be reallocated if *out == in.
-bstr sd_ass_to_plaintext(char **out, const char *in);
+inline bstr sd_ass_to_plaintext(char **out, const char *in) {
+    struct bstr r;
+    r.start = NULL;
+    r.len = 0;
+    return r;
+}
 
 #endif
diff --git a/sub/sd_ass.c b/sub/sd_ass.c
deleted file mode 100644
index 47b3109ec7..0000000000
--- a/sub/sd_ass.c
+++ /dev/null
@@ -1,1174 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <assert.h>
-#include <string.h>
-#include <math.h>
-#include <limits.h>
-
-#include <libavutil/common.h>
-#include <ass/ass.h>
-
-#include "mpv_talloc.h"
-
-#include "config.h"
-#include "options/m_config.h"
-#include "options/options.h"
-#include "common/common.h"
-#include "common/msg.h"
-#include "demux/demux.h"
-#include "video/csputils.h"
-#include "video/mp_image.h"
-#include "dec_sub.h"
-#include "ass_mp.h"
-#include "sd.h"
-
-struct sd_ass_priv {
-    struct ass_library *ass_library;
-    struct ass_renderer *ass_renderer;
-    struct ass_track *ass_track;
-    struct ass_track *shadow_track; // for --sub-ass=no rendering
-    bool ass_configured;
-    bool is_converted;
-    struct lavc_conv *converter;
-    struct sd_filter **filters;
-    int num_filters;
-    bool clear_once;
-    struct mp_ass_packer *packer;
-    struct sub_bitmap_copy_cache *copy_cache;
-    bstr last_text;
-    struct mp_image_params video_params;
-    struct mp_image_params last_params;
-    struct mp_osd_res osd;
-    struct seen_packet *seen_packets;
-    int num_seen_packets;
-    int *packets_animated;
-    int num_packets_animated;
-    bool check_animated;
-    bool duration_unknown;
-};
-
-struct seen_packet {
-    int64_t pos;
-    double pts;
-};
-
-static void mangle_colors(struct sd *sd, struct sub_bitmaps *parts);
-static void fill_plaintext(struct sd *sd, double pts);
-
-static const struct sd_filter_functions *const filters[] = {
-    // Note: list order defines filter order.
-    &sd_filter_sdh,
-#if HAVE_POSIX
-    &sd_filter_regex,
-#endif
-#if HAVE_JAVASCRIPT
-    &sd_filter_jsre,
-#endif
-    NULL,
-};
-
-// Add default styles, if the track does not have any styles yet.
-// Apply style overrides if the user provides any.
-static void mp_ass_add_default_styles(ASS_Track *track, struct mp_subtitle_opts *opts,
-                                      struct mp_subtitle_shared_opts *shared_opts, int order)
-{
-    if (opts->ass_styles_file && shared_opts->ass_style_override[order])
-        ass_read_styles(track, opts->ass_styles_file, NULL);
-
-    if (track->n_styles == 0) {
-        if (!track->PlayResY) {
-            track->PlayResX = MP_ASS_FONT_PLAYRESX;
-            track->PlayResY = MP_ASS_FONT_PLAYRESY;
-        }
-        track->Kerning = true;
-        int sid = ass_alloc_style(track);
-        track->default_style = sid;
-        ASS_Style *style = track->styles + sid;
-        style->Name = strdup("Default");
-        mp_ass_set_style(style, track->PlayResY, opts->sub_style);
-    }
-
-    if (shared_opts->ass_style_override[order])
-        ass_process_force_style(track);
-}
-
-static const char *const font_mimetypes[] = {
-    "application/x-truetype-font",
-    "application/vnd.ms-opentype",
-    "application/x-font-ttf",
-    "application/x-font", // probably incorrect
-    "application/font-sfnt",
-    "font/collection",
-    "font/otf",
-    "font/sfnt",
-    "font/ttf",
-    NULL
-};
-
-static const char *const font_exts[] = {".ttf", ".ttc", ".otf", ".otc", NULL};
-
-static bool attachment_is_font(struct mp_log *log, struct demux_attachment *f)
-{
-    if (!f->name || !f->type || !f->data || !f->data_size)
-        return false;
-    for (int n = 0; font_mimetypes[n]; n++) {
-        if (strcmp(font_mimetypes[n], f->type) == 0)
-            return true;
-    }
-    // fallback: match against file extension
-    char *ext = strlen(f->name) > 4 ? f->name + strlen(f->name) - 4 : "";
-    for (int n = 0; font_exts[n]; n++) {
-        if (strcasecmp(ext, font_exts[n]) == 0) {
-            mp_warn(log, "Loading font attachment '%s' with MIME type %s. "
-                    "Assuming this is a broken Matroska file, which was "
-                    "muxed without setting a correct font MIME type.\n",
-                    f->name, f->type);
-            return true;
-        }
-    }
-    return false;
-}
-
-static void add_subtitle_fonts(struct sd *sd)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    struct mp_subtitle_opts *opts = sd->opts;
-    if (!opts->ass_enabled || !opts->use_embedded_fonts || !sd->attachments)
-        return;
-    for (int i = 0; i < sd->attachments->num_entries; i++) {
-        struct demux_attachment *f = &sd->attachments->entries[i];
-        if (attachment_is_font(sd->log, f))
-            ass_add_font(ctx->ass_library, f->name, f->data, f->data_size);
-    }
-}
-
-static void filters_destroy(struct sd *sd)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-
-    for (int n = 0; n < ctx->num_filters; n++) {
-        struct sd_filter *ft = ctx->filters[n];
-        if (ft->driver->uninit)
-            ft->driver->uninit(ft);
-        talloc_free(ft);
-    }
-    ctx->num_filters = 0;
-}
-
-static void filters_init(struct sd *sd)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-
-    filters_destroy(sd);
-
-    for (int n = 0; filters[n]; n++) {
-        struct sd_filter *ft = talloc_ptrtype(ctx, ft);
-        *ft = (struct sd_filter){
-            .global = sd->global,
-            .log = sd->log,
-            .opts = mp_get_config_group(ft, sd->global, &mp_sub_filter_opts),
-            .driver = filters[n],
-            .codec = "ass",
-            .event_format = talloc_strdup(ft, ctx->ass_track->event_format),
-        };
-        if (ft->driver->init(ft)) {
-            MP_TARRAY_APPEND(ctx, ctx->filters, ctx->num_filters, ft);
-        } else {
-            talloc_free(ft);
-        }
-    }
-}
-
-static void enable_output(struct sd *sd, bool enable)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    if (enable == !!ctx->ass_renderer)
-        return;
-    if (ctx->ass_renderer) {
-        ass_renderer_done(ctx->ass_renderer);
-        ctx->ass_renderer = NULL;
-    } else {
-        ctx->ass_renderer = ass_renderer_init(ctx->ass_library);
-
-        mp_ass_configure_fonts(ctx->ass_renderer, sd->opts->sub_style,
-                               sd->global, sd->log);
-    }
-}
-
-static void assobjects_init(struct sd *sd)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    struct mp_subtitle_opts *opts = sd->opts;
-    struct mp_subtitle_shared_opts *shared_opts = sd->shared_opts;
-
-    ctx->ass_library = mp_ass_init(sd->global, sd->opts->sub_style, sd->log);
-    ass_set_extract_fonts(ctx->ass_library, opts->use_embedded_fonts);
-
-    add_subtitle_fonts(sd);
-
-    if (shared_opts->ass_style_override[sd->order])
-        ass_set_style_overrides(ctx->ass_library, opts->ass_style_override_list);
-
-    ctx->ass_track = ass_new_track(ctx->ass_library);
-    ctx->ass_track->track_type = TRACK_TYPE_ASS;
-
-    ctx->shadow_track = ass_new_track(ctx->ass_library);
-    ctx->shadow_track->PlayResX = MP_ASS_FONT_PLAYRESX;
-    ctx->shadow_track->PlayResY = MP_ASS_FONT_PLAYRESY;
-    mp_ass_add_default_styles(ctx->shadow_track, opts, shared_opts, sd->order);
-
-    char *extradata = sd->codec->extradata;
-    int extradata_size = sd->codec->extradata_size;
-    if (ctx->converter) {
-        extradata = lavc_conv_get_extradata(ctx->converter);
-        extradata_size = extradata ? strlen(extradata) : 0;
-    }
-    if (extradata)
-        ass_process_codec_private(ctx->ass_track, extradata, extradata_size);
-
-    mp_ass_add_default_styles(ctx->ass_track, opts, shared_opts, sd->order);
-
-#if LIBASS_VERSION >= 0x01302000
-    ass_set_check_readorder(ctx->ass_track, sd->opts->sub_clear_on_seek ? 0 : 1);
-#endif
-
-    enable_output(sd, true);
-}
-
-static void assobjects_destroy(struct sd *sd)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-
-    ass_free_track(ctx->ass_track);
-    ass_free_track(ctx->shadow_track);
-    enable_output(sd, false);
-    ass_library_done(ctx->ass_library);
-}
-
-static int init(struct sd *sd)
-{
-    struct sd_ass_priv *ctx = talloc_zero(sd, struct sd_ass_priv);
-    sd->priv = ctx;
-
-    // Note: accept "null" as alias for "ass", so EDL delay_open subtitle
-    //       streams work.
-    if (strcmp(sd->codec->codec, "ass") != 0 &&
-        strcmp(sd->codec->codec, "null") != 0)
-    {
-        ctx->is_converted = true;
-        ctx->converter = lavc_conv_create(sd);
-        if (!ctx->converter)
-            return -1;
-
-        if (strcmp(sd->codec->codec, "eia_608") == 0)
-            ctx->duration_unknown = 1;
-    }
-
-    assobjects_init(sd);
-    filters_init(sd);
-
-    ctx->packer = mp_ass_packer_alloc(ctx);
-
-    // Subtitles does not have any profile value, so put the converted type as a profile.
-    const char **desc = ctx->converter ? &sd->codec->codec_profile : &sd->codec->codec_desc;
-    switch (ctx->ass_track->track_type) {
-    case TRACK_TYPE_ASS:
-        *desc = "Advanced Sub Station Alpha";
-        break;
-    case TRACK_TYPE_SSA:
-        *desc = "Sub Station Alpha";
-        break;
-    }
-
-    return 0;
-}
-
-// Check if subtitle has events that would cause it to be animated inside {}
-static bool is_animated(const char *str)
-{
-    const char *begin = str;
-    while ((str = strchr(str, '{'))) {
-        if (str++ > begin && str[-2] == '\\')
-            continue;
-
-        const char *end = strchr(str, '}');
-        if (!end)
-            return false;
-
-        while ((str = memchr(str, '\\', end - str))) {
-            while (str[0] == '\\')
-                ++str;
-            while (str[0] == ' ' || str[0] == '\t')
-                ++str;
-            if (str[0] == 'k' || str[0] == 'K' || str[0] == 't' ||
-                (str[0] == 'f' && str[1] == 'a' && str[2] == 'd') ||
-                (str[0] == 'm' && str[1] == 'o' && str[2] == 'v' && str[3] == 'e'))
-            {
-                return true;
-            }
-        }
-
-        str = end + 1;
-    }
-
-    return false;
-}
-
-// Note: pkt is not necessarily a fully valid refcounted packet.
-static void filter_and_add(struct sd *sd, struct demux_packet *pkt)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    struct demux_packet *orig_pkt = pkt;
-    ASS_Track *track = ctx->ass_track;
-    int old_n_events = track->n_events;
-
-    for (int n = 0; n < ctx->num_filters; n++) {
-        struct sd_filter *ft = ctx->filters[n];
-        struct demux_packet *npkt = ft->driver->filter(ft, pkt);
-        if (pkt != npkt && pkt != orig_pkt)
-            talloc_free(pkt);
-        pkt = npkt;
-        if (!pkt)
-            return;
-    }
-
-    ass_process_chunk(ctx->ass_track, pkt->buffer, pkt->len,
-                      llrint(pkt->pts * 1000),
-                      llrint(pkt->duration * 1000));
-
-    // This bookkeeping only has any practical use for ASS subs
-    // over a VO with no video.
-    if (!ctx->is_converted) {
-        if (!pkt->seen) {
-            for (int n = track->n_events - 1; n >= 0; n--) {
-                if (n + 1 == old_n_events || pkt->animated == 1)
-                    break;
-                ASS_Event *event = &track->events[n];
-                // Might as well mark pkt->animated here with effects if we can.
-                pkt->animated = (event->Effect && event->Effect[0]) ? 1 : -1;
-                if (ctx->check_animated && pkt->animated != 1)
-                    pkt->animated = is_animated(event->Text);
-            }
-            MP_TARRAY_APPEND(ctx, ctx->packets_animated, ctx->num_packets_animated, pkt->animated);
-        } else {
-            if (ctx->check_animated && ctx->packets_animated[pkt->seen_pos] == -1) {
-                for (int n = track->n_events - 1; n >= 0; n--) {
-                    if (n + 1 == old_n_events || pkt->animated == 1)
-                        break;
-                    ASS_Event *event = &track->events[n];
-                    ctx->packets_animated[pkt->seen_pos] = is_animated(event->Text);
-                    pkt->animated = ctx->packets_animated[pkt->seen_pos];
-                }
-            } else {
-                pkt->animated = ctx->packets_animated[pkt->seen_pos];
-            }
-        }
-    }
-
-    if (pkt != orig_pkt)
-        talloc_free(pkt);
-}
-
-// Test if the packet with the given file position and pts was already consumed.
-// Return false if the packet is new (and add it to the internal list), and
-// return true if it was already seen.
-static bool check_packet_seen(struct sd *sd, struct demux_packet *packet)
-{
-    struct sd_ass_priv *priv = sd->priv;
-    int a = 0;
-    int b = priv->num_seen_packets;
-    while (a < b) {
-        int mid = a + (b - a) / 2;
-        struct seen_packet *seen_packet = &priv->seen_packets[mid];
-        if (packet->pos == seen_packet->pos && packet->pts == seen_packet->pts) {
-            packet->seen_pos = mid;
-            return true;
-        }
-        if (packet->pos > seen_packet->pos ||
-            (packet->pos == seen_packet->pos && packet->pts > seen_packet->pts)) {
-            a = mid + 1;
-        } else {
-            b = mid;
-        }
-    }
-    packet->seen_pos = a;
-    MP_TARRAY_INSERT_AT(priv, priv->seen_packets, priv->num_seen_packets, a,
-                        (struct seen_packet){packet->pos, packet->pts});
-    return false;
-}
-
-#define UNKNOWN_DURATION (INT_MAX / 1000)
-
-static void decode(struct sd *sd, struct demux_packet *packet)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    ASS_Track *track = ctx->ass_track;
-
-    packet->sub_duration = packet->duration;
-
-    if (ctx->converter) {
-        if (!sd->opts->sub_clear_on_seek && packet->pos >= 0 &&
-            check_packet_seen(sd, packet))
-            return;
-
-        double sub_pts = 0;
-        double sub_duration = 0;
-        char **r = lavc_conv_decode(ctx->converter, packet, &sub_pts,
-                                    &sub_duration);
-        if (sd->opts->sub_stretch_durations ||
-            packet->duration < 0 || sub_duration == UINT32_MAX) {
-            if (!ctx->duration_unknown) {
-                MP_VERBOSE(sd, "Subtitle with unknown duration.\n");
-                ctx->duration_unknown = true;
-            }
-            sub_duration = UNKNOWN_DURATION;
-        }
-
-        for (int n = 0; r && r[n]; n++) {
-            struct demux_packet pkt2 = {
-                .pts = sub_pts,
-                .duration = sub_duration,
-                .buffer = r[n],
-                .len = strlen(r[n]),
-            };
-            filter_and_add(sd, &pkt2);
-        }
-        if (ctx->duration_unknown) {
-            for (int n = track->n_events - 2; n >= 0; n--) {
-                if (track->events[n].Duration == UNKNOWN_DURATION * 1000) {
-                    if (track->events[n].Start != track->events[n + 1].Start) {
-                        track->events[n].Duration = track->events[n + 1].Start -
-                                                    track->events[n].Start;
-                    } else {
-                        track->events[n].Duration = track->events[n + 1].Duration;
-                    }
-                }
-            }
-        }
-    } else {
-        // Note that for this packet format, libass has an internal mechanism
-        // for discarding duplicate (already seen) packets but we check this
-        // anyways for our purposes for ASS subtitles.
-        packet->seen = check_packet_seen(sd, packet);
-        filter_and_add(sd, packet);
-    }
-}
-
-// Calculate the height used for scaling subtitle text size so --sub-scale-with-window
-// can undo this scale and use frame size instead. The algorithm used is the following:
-// - If use_margins is disabled, the text is scaled with the visual size of the video.
-// - If use_margins is enabled, the text is scaled with the size of the video
-//   as if the video is resized to "fit" the size of the frame.
-static float get_libass_scale_height(struct mp_osd_res *dim, bool use_margins)
-{
-    float vidw = dim->w - (dim->ml + dim->mr);
-    float vidh = dim->h - (dim->mt + dim->mb);
-    if (!use_margins || vidw < 1.0)
-        return vidh;
-    else
-        return MPMIN(dim->h, dim->w / vidw * vidh);
-}
-
-static void configure_ass(struct sd *sd, struct mp_osd_res *dim,
-                          bool converted, ASS_Track *track)
-{
-    struct mp_subtitle_opts *opts = sd->opts;
-    struct mp_subtitle_shared_opts *shared_opts = sd->shared_opts;
-    struct sd_ass_priv *ctx = sd->priv;
-    ASS_Renderer *priv = ctx->ass_renderer;
-
-    ass_set_frame_size(priv, dim->w, dim->h);
-    ass_set_margins(priv, dim->mt, dim->mb, dim->ml, dim->mr);
-
-    bool set_use_margins = false;
-    float set_sub_pos = 0.0f;
-    float set_line_spacing = 0;
-    float set_font_scale = 1;
-    int set_hinting = 0;
-    bool set_scale_with_window = false;
-    bool set_scale_by_window = true;
-    bool total_override = false;
-    // With forced overrides, apply the --sub-* specific options
-    if (converted || shared_opts->ass_style_override[sd->order] == ASS_STYLE_OVERRIDE_FORCE) {
-        set_scale_with_window = opts->sub_scale_with_window;
-        set_use_margins = opts->sub_use_margins;
-        set_scale_by_window = opts->sub_scale_by_window;
-        total_override = true;
-    } else {
-        set_scale_with_window = opts->ass_scale_with_window;
-        set_use_margins = opts->ass_use_margins;
-    }
-    if (converted || shared_opts->ass_style_override[sd->order]) {
-        set_sub_pos = 100.0f - shared_opts->sub_pos[sd->order];
-        set_line_spacing = opts->ass_line_spacing;
-        set_hinting = opts->ass_hinting;
-    }
-    if (total_override || shared_opts->ass_style_override[sd->order] == ASS_STYLE_OVERRIDE_SCALE) {
-        set_font_scale = opts->sub_scale;
-    }
-    if (set_scale_with_window) {
-        set_font_scale *= dim->h / MPMAX(get_libass_scale_height(dim, set_use_margins), 1);
-    }
-    if (!set_scale_by_window) {
-        double factor = dim->h / 720.0;
-        if (factor != 0.0)
-            set_font_scale /= factor;
-    }
-    ass_set_use_margins(priv, set_use_margins);
-    ass_set_line_position(priv, set_sub_pos);
-    ass_set_shaper(priv, opts->ass_shaper);
-    int set_force_flags = 0;
-    if (total_override) {
-        set_force_flags |= ASS_OVERRIDE_BIT_FONT_NAME
-                            | ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS
-                            | ASS_OVERRIDE_BIT_COLORS
-                            | ASS_OVERRIDE_BIT_BORDER
-                            | ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE;
-    }
-    if (shared_opts->ass_style_override[sd->order] == ASS_STYLE_OVERRIDE_SCALE)
-        set_force_flags |= ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE;
-    if (converted)
-        set_force_flags |= ASS_OVERRIDE_BIT_ALIGNMENT;
-#if LIBASS_VERSION >= 0x01306000
-    if ((converted || shared_opts->ass_style_override[sd->order]) && opts->ass_justify)
-        set_force_flags |= ASS_OVERRIDE_BIT_JUSTIFY;
-#endif
-    ass_set_selective_style_override_enabled(priv, set_force_flags);
-    ASS_Style style = {0};
-    mp_ass_set_style(&style, MP_ASS_FONT_PLAYRESY, opts->sub_style);
-    ass_set_selective_style_override(priv, &style);
-    free(style.FontName);
-    if (converted && track->default_style < track->n_styles) {
-        mp_ass_set_style(track->styles + track->default_style,
-                         track->PlayResY, opts->sub_style);
-    }
-    ass_set_font_scale(priv, set_font_scale);
-    ass_set_hinting(priv, set_hinting);
-    ass_set_line_spacing(priv, set_line_spacing);
-#if LIBASS_VERSION >= 0x01600010
-    if (converted) {
-        ass_track_set_feature(track, ASS_FEATURE_WRAP_UNICODE, 1);
-        if (!opts->sub_vsfilter_bidi_compat) {
-            for (int n = 0; n < track->n_styles; n++) {
-                track->styles[n].Encoding = -1;
-            }
-            ass_track_set_feature(track, ASS_FEATURE_BIDI_BRACKETS, 1);
-            ass_track_set_feature(track, ASS_FEATURE_WHOLE_TEXT_LAYOUT, 1);
-        }
-    }
-#endif
-    if (converted) {
-        bool override_playres = true;
-        char **ass_style_override_list = opts->ass_style_override_list;
-        for (int i = 0; ass_style_override_list && ass_style_override_list[i]; i++) {
-            if (bstr_find0(bstr0(ass_style_override_list[i]), "PlayResX") >= 0)
-                override_playres = false;
-        }
-
-        // srt to ass conversion from ffmpeg has fixed PlayResX of 384 with an
-        // aspect of 4:3. Starting with libass f08f8ea5 (pre 0.17) PlayResX
-        // affects shadow and border widths, among others, so to render borders
-        // and shadows correctly, we adjust PlayResX according to the DAR.
-        // But PlayResX also affects margins, so we adjust those too.
-        // This should ensure basic srt-to-ass ffmpeg conversion has correct
-        // borders, but there could be other issues with some srt extensions
-        // and/or different source formats which would be exposed over time.
-        // Make these adjustments only if the user didn't set PlayResX.
-        if (override_playres) {
-            int vidw = dim->w - (dim->ml + dim->mr);
-            int vidh = dim->h - (dim->mt + dim->mb);
-            int old_playresx = track->PlayResX;
-            track->PlayResX = track->PlayResY * (double)vidw / MPMAX(vidh, 1);
-            double fix_margins = track->PlayResX / (double)old_playresx;
-            for (int n = 0; n < track->n_styles; n++) {
-                track->styles[n].MarginL = lrint(track->styles[n].MarginL * fix_margins);
-                track->styles[n].MarginR = lrint(track->styles[n].MarginR * fix_margins);
-                track->styles[n].MarginV = lrint(track->styles[n].MarginV * set_font_scale);
-            }
-        }
-    }
-}
-
-static bool has_overrides(char *s)
-{
-    if (!s)
-        return false;
-    return strstr(s, "\\pos") || strstr(s, "\\move") || strstr(s, "\\clip") ||
-           strstr(s, "\\iclip") || strstr(s, "\\org") || strstr(s, "\\p");
-}
-
-#define END(ev) ((ev)->Start + (ev)->Duration)
-
-static long long find_timestamp(struct sd *sd, double pts)
-{
-    struct sd_ass_priv *priv = sd->priv;
-    if (pts == MP_NOPTS_VALUE)
-        return 0;
-
-    long long ts = llrint(pts * 1000);
-
-    if (!sd->opts->sub_fix_timing ||
-        sd->shared_opts->ass_style_override[sd->order] == ASS_STYLE_OVERRIDE_NONE)
-        return ts;
-
-    // Try to fix small gaps and overlaps.
-    ASS_Track *track = priv->ass_track;
-    int threshold = SUB_GAP_THRESHOLD * 1000;
-    int keep = SUB_GAP_KEEP * 1000;
-
-    // Find the "current" event.
-    ASS_Event *ev[2] = {0};
-    int n_ev = 0;
-    for (int n = 0; n < track->n_events; n++) {
-        ASS_Event *event = &track->events[n];
-        if (ts >= event->Start - threshold && ts <= END(event) + threshold) {
-            if (n_ev >= MP_ARRAY_SIZE(ev))
-                return ts; // multiple overlaps - give up (probably complex subs)
-            ev[n_ev++] = event;
-        }
-    }
-
-    if (n_ev != 2)
-        return ts;
-
-    // Simple/minor heuristic against destroying typesetting.
-    if (ev[0]->Style != ev[1]->Style || has_overrides(ev[0]->Text) ||
-        has_overrides(ev[1]->Text))
-        return ts;
-
-    // Sort by start timestamps.
-    if (ev[0]->Start > ev[1]->Start)
-        MPSWAP(ASS_Event*, ev[0], ev[1]);
-
-    // We want to fix partial overlaps only.
-    if (END(ev[0]) >= END(ev[1]))
-        return ts;
-
-    if (ev[0]->Duration < keep || ev[1]->Duration < keep)
-        return ts;
-
-    // Gap between the events -> move ts to show the end of the first event.
-    if (ts >= END(ev[0]) && ts < ev[1]->Start && END(ev[0]) < ev[1]->Start &&
-        END(ev[0]) + threshold >= ev[1]->Start)
-        return END(ev[0]) - 1;
-
-    // Overlap -> move ts to the (exclusive) end of the first event.
-    // Relies on the fact that the ASS_Renderer has no overlap registered, even
-    // if there is one. This happens to work because we never render the
-    // overlapped state, and libass never resolves a collision.
-    if (ts >= ev[1]->Start && ts <= END(ev[0]) && END(ev[0]) > ev[1]->Start &&
-        END(ev[0]) <= ev[1]->Start + threshold)
-        return END(ev[0]);
-
-    return ts;
-}
-
-#undef END
-
-static struct sub_bitmaps *get_bitmaps(struct sd *sd, struct mp_osd_res dim,
-                                       int format, double pts)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    struct mp_subtitle_opts *opts = sd->opts;
-    struct mp_subtitle_shared_opts *shared_opts = sd->shared_opts;
-    bool no_ass = !opts->ass_enabled ||
-        shared_opts->ass_style_override[sd->order] == ASS_STYLE_OVERRIDE_STRIP;
-    bool converted = (ctx->is_converted && !lavc_conv_is_styled(ctx->converter)) || no_ass;
-    ASS_Track *track = no_ass ? ctx->shadow_track : ctx->ass_track;
-    ASS_Renderer *renderer = ctx->ass_renderer;
-    struct sub_bitmaps *res = &(struct sub_bitmaps){0};
-
-    // Always update the osd_res
-    struct mp_osd_res old_osd = ctx->osd;
-    ctx->osd = dim;
-
-    if (pts == MP_NOPTS_VALUE || !renderer)
-        goto done;
-
-    // Currently no supported text sub formats support a distinction between forced
-    // and unforced lines, so we just assume everything's unforced and discard everything.
-    // If we ever see a format that makes this distinction, we can add support here.
-    if (opts->sub_forced_events_only)
-        goto done;
-
-    double scale = dim.display_par;
-    if (!converted && (!shared_opts->ass_style_override[sd->order] ||
-                       opts->ass_use_video_data >= 1))
-    {
-        // Let's factor in video PAR for vsfilter compatibility:
-        double par = opts->ass_video_aspect > 0 ?
-                opts->ass_video_aspect :
-                ctx->video_params.p_w / (double)ctx->video_params.p_h;
-        if (isnormal(par))
-            scale *= par;
-    }
-    if (!ctx->ass_configured || !osd_res_equals(old_osd, ctx->osd)) {
-        configure_ass(sd, &dim, converted, track);
-        ctx->ass_configured = true;
-    }
-    ass_set_pixel_aspect(renderer, scale);
-    if (!converted && (!shared_opts->ass_style_override[sd->order] ||
-                       opts->ass_use_video_data >= 2))
-    {
-        ass_set_storage_size(renderer, ctx->video_params.w, ctx->video_params.h);
-    } else {
-        ass_set_storage_size(renderer, 0, 0);
-    }
-    long long ts = find_timestamp(sd, pts);
-
-    if (no_ass)
-        fill_plaintext(sd, pts);
-
-    int changed;
-    ASS_Image *imgs = ass_render_frame(renderer, track, ts, &changed);
-    mp_ass_packer_pack(ctx->packer, &imgs, 1, changed, !converted, format, res);
-
-done:
-    // mangle_colors() modifies the color field, so copy the thing _before_.
-    res = sub_bitmaps_copy(&ctx->copy_cache, res);
-
-    if (!converted && res)
-        mangle_colors(sd, res);
-
-    return res;
-}
-
-#define MAX_BUF_SIZE 1024 * 1024
-#define MIN_EXPAND_SIZE 4096
-
-static void append(bstr *b, char c)
-{
-    bstr_xappend(NULL, b, (bstr){&c, 1});
-}
-
-static void ass_to_plaintext(bstr *b, const char *in)
-{
-    const char *open_tag_pos = NULL;
-    bool in_drawing = false;
-    while (*in) {
-        if (open_tag_pos) {
-            if (in[0] == '}') {
-                in += 1;
-                open_tag_pos = NULL;
-            } else if (in[0] == '\\' && in[1] == 'p' && in[2] != 'o') {
-                in += 2;
-                // Skip text between \pN and \p0 tags. A \p without a number
-                // is the same as \p0, and leading 0s are also allowed.
-                in_drawing = false;
-                while (in[0] >= '0' && in[0] <= '9') {
-                    if (in[0] != '0')
-                        in_drawing = true;
-                    in += 1;
-                }
-            } else {
-                in += 1;
-            }
-        } else {
-            if (in[0] == '\\' && (in[1] == 'N' || in[1] == 'n')) {
-                in += 2;
-                append(b, '\n');
-            } else if (in[0] == '\\' && in[1] == 'h') {
-                in += 2;
-                append(b, ' ');
-            } else if (in[0] == '{') {
-                open_tag_pos = in;
-                in += 1;
-            } else {
-                if (!in_drawing)
-                    append(b, in[0]);
-                in += 1;
-            }
-        }
-    }
-    // A '{' without a closing '}' is always visible.
-    if (open_tag_pos) {
-        bstr_xappend(NULL, b, bstr0(open_tag_pos));
-    }
-}
-
-// Empty string counts as whitespace.
-static bool is_whitespace_only(bstr b)
-{
-    for (int n = 0; n < b.len; n++) {
-        if (b.start[n] != ' ' && b.start[n] != '\t')
-            return false;
-    }
-    return true;
-}
-
-static bstr get_text_buf(struct sd *sd, double pts, enum sd_text_type type)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    ASS_Track *track = ctx->ass_track;
-
-    if (pts == MP_NOPTS_VALUE)
-        return (bstr){0};
-    long long ipts = find_timestamp(sd, pts);
-
-    bstr *b = &ctx->last_text;
-
-    if (!b->start)
-        b->start = talloc_size(ctx, 4096);
-
-    b->len = 0;
-
-    for (int i = 0; i < track->n_events; ++i) {
-        ASS_Event *event = track->events + i;
-        if (ipts >= event->Start && ipts < event->Start + event->Duration) {
-            if (event->Text) {
-                int start = b->len;
-                if (type == SD_TEXT_TYPE_PLAIN) {
-                    ass_to_plaintext(b, event->Text);
-                } else if (type == SD_TEXT_TYPE_ASS_FULL) {
-                    long long s = event->Start;
-                    long long e = s + event->Duration;
-
-                    ASS_Style *style = (event->Style < 0 || event->Style >= track->n_styles) ? NULL : &track->styles[event->Style];
-
-                    int sh = (s / 60 / 60 / 1000);
-                    int sm = (s / 60 / 1000) % 60;
-                    int ss = (s / 1000) % 60;
-                    int sc = (s / 10) % 100;
-                    int eh = (e / 60 / 60 / 1000);
-                    int em = (e / 60 / 1000) % 60;
-                    int es = (e / 1000) % 60;
-                    int ec = (e / 10) % 100;
-
-                    bstr_xappend_asprintf(NULL, b, "Dialogue: %d,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s,%s,%04d,%04d,%04d,%s,%s",
-                        event->Layer,
-                        sh, sm, ss, sc,
-                        eh, em, es, ec,
-                        (style && style->Name) ? style->Name : "", event->Name,
-                        event->MarginL, event->MarginR, event->MarginV,
-                        event->Effect, event->Text);
-                } else {
-                    bstr_xappend(NULL, b, bstr0(event->Text));
-                }
-                if (is_whitespace_only(bstr_cut(*b, start))) {
-                    b->len = start;
-                } else {
-                    append(b, '\n');
-                }
-            }
-        }
-    }
-
-    bstr_eatend(b, (bstr)bstr0_lit("\n"));
-
-    return *b;
-}
-
-static char *get_text(struct sd *sd, double pts, enum sd_text_type type)
-{
-    return bstrto0(NULL, get_text_buf(sd, pts, type));
-}
-
-static struct sd_times get_times(struct sd *sd, double pts)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    ASS_Track *track = ctx->ass_track;
-    struct sd_times res = { .start = MP_NOPTS_VALUE, .end = MP_NOPTS_VALUE };
-
-    if (pts == MP_NOPTS_VALUE)
-        return res;
-
-    long long ipts = find_timestamp(sd, pts);
-
-    for (int i = 0; i < track->n_events; ++i) {
-        ASS_Event *event = track->events + i;
-        if (ipts >= event->Start && ipts < event->Start + event->Duration) {
-            double start = event->Start / 1000.0;
-            double end = event->Duration == UNKNOWN_DURATION ?
-                MP_NOPTS_VALUE : (event->Start + event->Duration) / 1000.0;
-
-            if (res.start == MP_NOPTS_VALUE || res.start > start)
-                res.start = start;
-
-            if (res.end == MP_NOPTS_VALUE || res.end < end)
-                res.end = end;
-        }
-    }
-
-    return res;
-}
-
-static void fill_plaintext(struct sd *sd, double pts)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    ASS_Track *track = ctx->shadow_track;
-
-    ass_flush_events(track);
-
-    bstr text = get_text_buf(sd, pts, SD_TEXT_TYPE_PLAIN);
-    if (!text.len)
-        return;
-
-    bstr dst = {0};
-
-    while (text.len) {
-        if (*text.start == '{') {
-            bstr_xappend(NULL, &dst, bstr0("\\{"));
-            text = bstr_cut(text, 1);
-        } else if (*text.start == '\\') {
-            bstr_xappend(NULL, &dst, bstr0("\\"));
-            // Break ASS escapes with U+2060 WORD JOINER
-            mp_append_utf8_bstr(NULL, &dst, 0x2060);
-            text = bstr_cut(text, 1);
-        }
-
-        int i = bstrcspn(text, "{\\");
-        bstr_xappend(NULL, &dst, (bstr){text.start, i});
-        text = bstr_cut(text, i);
-    }
-
-    if (!dst.start)
-        return;
-
-    int n = ass_alloc_event(track);
-    ASS_Event *event = track->events + n;
-    event->Start = 0;
-    event->Duration = INT_MAX;
-    event->Style = track->default_style;
-    event->Text = strdup(dst.start);
-
-    talloc_free(dst.start);
-}
-
-static void reset(struct sd *sd)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    if (sd->opts->sub_clear_on_seek || ctx->clear_once) {
-        ass_flush_events(ctx->ass_track);
-        ctx->num_seen_packets = 0;
-        sd->preload_ok = false;
-        ctx->clear_once = false;
-    }
-    if (ctx->converter)
-        lavc_conv_reset(ctx->converter);
-}
-
-static void uninit(struct sd *sd)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-
-    filters_destroy(sd);
-    if (ctx->converter)
-        lavc_conv_uninit(ctx->converter);
-    assobjects_destroy(sd);
-    talloc_free(ctx->copy_cache);
-}
-
-static int control(struct sd *sd, enum sd_ctrl cmd, void *arg)
-{
-    struct sd_ass_priv *ctx = sd->priv;
-    switch (cmd) {
-    case SD_CTRL_SUB_STEP: {
-        double *a = arg;
-        long long ts = llrint(a[0] * 1000.0);
-        long long res = ass_step_sub(ctx->ass_track, ts, a[1]);
-        if (!res)
-            return false;
-        // Try to account for overlapping durations
-        a[0] += res / 1000.0 + SUB_SEEK_OFFSET;
-        return true;
-    }
-    case SD_CTRL_SET_ANIMATED_CHECK:
-        ctx->check_animated = *(bool *)arg;
-        return CONTROL_OK;
-    case SD_CTRL_SET_VIDEO_PARAMS:
-        ctx->video_params = *(struct mp_image_params *)arg;
-        return CONTROL_OK;
-    case SD_CTRL_UPDATE_OPTS: {
-        int flags = (uintptr_t)arg;
-        if (flags & UPDATE_SUB_FILT) {
-            filters_destroy(sd);
-            filters_init(sd);
-            ctx->clear_once = true; // allow reloading on seeks
-            reset(sd);
-        }
-        if (flags & UPDATE_SUB_HARD) {
-            // ass_track will be recreated, so clear duplicate cache
-            ctx->clear_once = true;
-            reset(sd);
-            assobjects_destroy(sd);
-            assobjects_init(sd);
-        }
-        ctx->ass_configured = false; // ass always needs to be reconfigured
-        return CONTROL_OK;
-    }
-    default:
-        return CONTROL_UNKNOWN;
-    }
-}
-
-const struct sd_functions sd_ass = {
-    .name = "ass",
-    .accept_packets_in_advance = true,
-    .init = init,
-    .decode = decode,
-    .get_bitmaps = get_bitmaps,
-    .get_text = get_text,
-    .get_times = get_times,
-    .control = control,
-    .reset = reset,
-    .select = enable_output,
-    .uninit = uninit,
-};
-
-// Disgusting hack for (xy-)vsfilter color compatibility.
-static void mangle_colors(struct sd *sd, struct sub_bitmaps *parts)
-{
-    struct mp_subtitle_opts *opts = sd->opts;
-    struct sd_ass_priv *ctx = sd->priv;
-    enum pl_color_system csp = 0;
-    enum pl_color_levels levels = 0;
-    if (opts->ass_vsfilter_color_compat == 0) // "no"
-        return;
-    bool force_601 = opts->ass_vsfilter_color_compat == 3;
-    ASS_Track *track = ctx->ass_track;
-    static const int ass_csp[] = {
-        [YCBCR_BT601_TV]        = PL_COLOR_SYSTEM_BT_601,
-        [YCBCR_BT601_PC]        = PL_COLOR_SYSTEM_BT_601,
-        [YCBCR_BT709_TV]        = PL_COLOR_SYSTEM_BT_709,
-        [YCBCR_BT709_PC]        = PL_COLOR_SYSTEM_BT_709,
-        [YCBCR_SMPTE240M_TV]    = PL_COLOR_SYSTEM_SMPTE_240M,
-        [YCBCR_SMPTE240M_PC]    = PL_COLOR_SYSTEM_SMPTE_240M,
-    };
-    static const int ass_levels[] = {
-        [YCBCR_BT601_TV]        = PL_COLOR_LEVELS_LIMITED,
-        [YCBCR_BT601_PC]        = PL_COLOR_LEVELS_FULL,
-        [YCBCR_BT709_TV]        = PL_COLOR_LEVELS_LIMITED,
-        [YCBCR_BT709_PC]        = PL_COLOR_LEVELS_FULL,
-        [YCBCR_SMPTE240M_TV]    = PL_COLOR_LEVELS_LIMITED,
-        [YCBCR_SMPTE240M_PC]    = PL_COLOR_LEVELS_FULL,
-    };
-    int trackcsp = track->YCbCrMatrix;
-    if (force_601)
-        trackcsp = YCBCR_BT601_TV;
-    // NONE is a bit random, but the intention is: don't modify colors.
-    if (trackcsp == YCBCR_NONE)
-        return;
-    if (trackcsp < sizeof(ass_csp) / sizeof(ass_csp[0]))
-        csp = ass_csp[trackcsp];
-    if (trackcsp < sizeof(ass_levels) / sizeof(ass_levels[0]))
-        levels = ass_levels[trackcsp];
-    if (trackcsp == YCBCR_DEFAULT) {
-        csp = PL_COLOR_SYSTEM_BT_601;
-        levels = PL_COLOR_LEVELS_LIMITED;
-    }
-    // Unknown colorspace (either YCBCR_UNKNOWN, or a valid value unknown to us)
-    if (!csp || !levels)
-        return;
-
-    struct mp_image_params params = ctx->video_params;
-
-    if (force_601) {
-        params.repr = (struct pl_color_repr){
-            .sys = PL_COLOR_SYSTEM_BT_709,
-            .levels = PL_COLOR_LEVELS_LIMITED,
-        };
-    }
-
-    if ((csp == params.repr.sys && levels == params.repr.levels) ||
-            params.repr.sys == PL_COLOR_SYSTEM_RGB) // Even VSFilter doesn't mangle on RGB video
-        return;
-
-    bool basic_conv = params.repr.sys == PL_COLOR_SYSTEM_BT_709 &&
-                      params.repr.levels == PL_COLOR_LEVELS_LIMITED &&
-                      csp == PL_COLOR_SYSTEM_BT_601 &&
-                      levels == PL_COLOR_LEVELS_LIMITED;
-
-    // With "basic", only do as much as needed for basic compatibility.
-    if (opts->ass_vsfilter_color_compat == 1 && !basic_conv)
-        return;
-
-    if (params.repr.sys != ctx->last_params.repr.sys ||
-        params.repr.levels != ctx->last_params.repr.levels)
-    {
-        int msgl = basic_conv ? MSGL_V : MSGL_WARN;
-        ctx->last_params = params;
-        MP_MSG(sd, msgl, "mangling colors like vsfilter: "
-               "RGB -> %s %s -> %s %s -> RGB\n",
-               m_opt_choice_str(pl_csp_names, csp),
-               m_opt_choice_str(pl_csp_levels_names, levels),
-               m_opt_choice_str(pl_csp_names, params.repr.sys),
-               m_opt_choice_str(pl_csp_names, params.repr.levels));
-    }
-
-    // Conversion that VSFilter would use
-    struct mp_csp_params vs_params = MP_CSP_PARAMS_DEFAULTS;
-    vs_params.repr.sys = csp;
-    vs_params.repr.levels = levels;
-    struct pl_transform3x3 vs_yuv2rgb;
-    mp_get_csp_matrix(&vs_params, &vs_yuv2rgb);
-    pl_transform3x3_invert(&vs_yuv2rgb);
-
-    // Proper conversion to RGB
-    struct mp_csp_params rgb_params = MP_CSP_PARAMS_DEFAULTS;
-    rgb_params.repr = params.repr;
-    rgb_params.color = params.color;
-    struct pl_transform3x3 vs2rgb;
-    mp_get_csp_matrix(&rgb_params, &vs2rgb);
-
-    for (int n = 0; n < parts->num_parts; n++) {
-        struct sub_bitmap *sb = &parts->parts[n];
-        uint32_t color = sb->libass.color;
-        int r = (color >> 24u) & 0xff;
-        int g = (color >> 16u) & 0xff;
-        int b = (color >>  8u) & 0xff;
-        int a = 0xff - (color & 0xff);
-        int rgb[3] = {r, g, b}, yuv[3];
-        mp_map_fixp_color(&vs_yuv2rgb, 8, rgb, 8, yuv);
-        mp_map_fixp_color(&vs2rgb, 8, yuv, 8, rgb);
-        sb->libass.color = MP_ASS_RGBA(rgb[0], rgb[1], rgb[2], a);
-    }
-}
-
-int sd_ass_fmt_offset(const char *evt_fmt)
-{
-    // "Text" is always last (as it's arbitrary content in buf), e.g. format:
-    // "Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"
-    int n = 0;
-    while (evt_fmt && (evt_fmt = strchr(evt_fmt, ',')))
-         evt_fmt++, n++;
-    return n-1;  // buffer is without the format's Start/End, with ReadOrder
-}
-
-bstr sd_ass_pkt_text(struct sd_filter *ft, struct demux_packet *pkt, int offset)
-{
-    // e.g. pkt->buffer ("4" is ReadOrder): "4,0,Default,,0,0,0,,fifth line"
-    bstr txt = {(char *)pkt->buffer, pkt->len}, t0 = txt;
-    while (offset-- > 0) {
-        int n = bstrchr(txt, ',');
-        if (n < 0) {  // shouldn't happen
-            MP_WARN(ft, "Malformed event '%.*s'\n", BSTR_P(t0));
-            return (bstr){NULL, 0};
-        }
-        txt = bstr_cut(txt, n+1);
-    }
-    return txt;
-}
-
-bstr sd_ass_to_plaintext(char **out, const char *in)
-{
-    bstr b = {*out};
-    ass_to_plaintext(&b, in);
-    *out = b.start;
-    return b;
-}
